# ~/.bashrc - sourced every time a terminal is opened

if [ $(tty) = /dev/tty1 ]; then startx exit 0; fi # start wm if tty is tty1

alias grep='grep --color=auto' # colour matching strings 
alias ls='ls -x --color=auto' # show all entries & colourze output
alias df='df -h' # make output human readable
alias wget="wget -c" # resume download if interupted
alias update-grub="sudo grub-mkconfig -o /boot/grub/grub.cfg" # update grub

alias size="du -hs" # show total size of directories and files
alias dcomp="sudo rm config.h && sudo make clean install"  # dwm and dmenu QoL
alias kcomp="sudo sv restart keyd && xset r rate 200 25"
eval "$(jump shell bash)"
export $(dbus-launch)

# insert a new line only when the last command output doesn't have one
# https://unix.stackexchange.com/a/647881
# https://github.com/dylanaraps/pure-bash-bible#get-the-current-cursor-position
# https://stackoverflow.com/a/52944692/520567
NEW_LINE() {
    local _ y x _
    local LIGHT_YELLOW="\001\033[1;93m\002"
    local     RESET="\001\e[0m\002"

    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
    if [[ "$x" != 1 ]]; then
        # printf "\n${LIGHT_YELLOW}^ missing newline (\\\n) at end of output\n${RESET}"
        printf "\n${RESET}"
    fi
}

BG='\[$(tput sgr0)\]' # background color
FG='\[\033[38;5;14m\]' # foreground color
# PROMPT_COMMAND=PROMPT_ECODE
export PS1="\$(NEW_LINE)${BG}┌──(${FG}\u@\h${BG})${BG}-[${FG}\W${BG}]\n└─$ " # v2 bash prompt

bind "set completion-ignore-case on" # ignore upper and lowercase when TAB completion
# enable programmable completion features (you don't need to enable this, if it's already enabled in /etc/bash.bashrc which is sourced from /etc/profile
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
      # for FILE in $XDG_DATA_HOME/bash-completion/completions/*; do source $FILE; done
      . /usr/share/bash-completion/bash_completion
  fi
fi
